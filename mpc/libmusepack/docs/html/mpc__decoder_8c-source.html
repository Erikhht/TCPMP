<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libmusepack: src/mpc_decoder.c Source File</title>
<link href="custom.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000002.html">src</a></div>
<h1>mpc_decoder.c</h1><a href="mpc__decoder_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment">  Copyright (c) 2005, The Musepack Development Team</span>
00003 <span class="comment">  All rights reserved.</span>
00004 <span class="comment"></span>
00005 <span class="comment">  Redistribution and use in source and binary forms, with or without</span>
00006 <span class="comment">  modification, are permitted provided that the following conditions are</span>
00007 <span class="comment">  met:</span>
00008 <span class="comment"></span>
00009 <span class="comment">  * Redistributions of source code must retain the above copyright</span>
00010 <span class="comment">  notice, this list of conditions and the following disclaimer.</span>
00011 <span class="comment"></span>
00012 <span class="comment">  * Redistributions in binary form must reproduce the above</span>
00013 <span class="comment">  copyright notice, this list of conditions and the following</span>
00014 <span class="comment">  disclaimer in the documentation and/or other materials provided</span>
00015 <span class="comment">  with the distribution.</span>
00016 <span class="comment"></span>
00017 <span class="comment">  * Neither the name of the The Musepack Development Team nor the</span>
00018 <span class="comment">  names of its contributors may be used to endorse or promote</span>
00019 <span class="comment">  products derived from this software without specific prior</span>
00020 <span class="comment">  written permission.</span>
00021 <span class="comment"></span>
00022 <span class="comment">  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
00023 <span class="comment">  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
00024 <span class="comment">  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
00025 <span class="comment">  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
00026 <span class="comment">  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
00027 <span class="comment">  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
00028 <span class="comment">  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
00029 <span class="comment">  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
00030 <span class="comment">  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
00031 <span class="comment">  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
00032 <span class="comment">  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
00033 <span class="comment">*/</span>
00034 
00037 
00038 <span class="preprocessor">#include "<a class="code" href="musepack_8h.html">musepack/musepack.h</a>"</span>
00039 <span class="preprocessor">#include "musepack/internal.h"</span>
00040 <span class="preprocessor">#include "<a class="code" href="requant_8h.html">musepack/requant.h</a>"</span>
00041 <span class="preprocessor">#include "<a class="code" href="huffman_8h.html">musepack/huffman.h</a>"</span>
00042 
00043 <span class="comment">//------------------------------------------------------------------------------</span>
00044 <span class="comment">// types</span>
00045 <span class="comment">//------------------------------------------------------------------------------</span>
00046 <span class="keyword">enum</span>
00047     {
00048         EQ_TAP = 13,                        <span class="comment">// length of FIR filter for EQ</span>
00049         DELAY = ((EQ_TAP + 1) / 2),         <span class="comment">// delay of FIR</span>
00050         FIR_BANDS = 4,                      <span class="comment">// number of subbands to be FIR filtered</span>
00051         MEMSIZE = MPC_DECODER_MEMSIZE,      <span class="comment">// overall buffer size</span>
00052         MEMSIZE2 = (MEMSIZE/2),             <span class="comment">// size of one buffer</span>
00053         MEMMASK = (MEMSIZE-1)
00054     };
00055 
00056 <span class="comment">//------------------------------------------------------------------------------</span>
00057 <span class="comment">// forward declarations</span>
00058 <span class="comment">//------------------------------------------------------------------------------</span>
00059 <span class="keywordtype">void</span> <a class="code" href="huffman_8h.html#a2">mpc_decoder_init_huffman_sv6</a>(mpc_decoder *d);
00060 <span class="keywordtype">void</span> <a class="code" href="huffman_8h.html#a4">mpc_decoder_init_huffman_sv7</a>(mpc_decoder *d);
00061 <span class="keywordtype">void</span> mpc_decoder_read_bitstream_sv6(mpc_decoder *d);
00062 <span class="keywordtype">void</span> mpc_decoder_read_bitstream_sv7(mpc_decoder *d);
00063 <span class="keywordtype">void</span> mpc_decoder_update_buffer(mpc_decoder *d, mpc_uint32_t RING);
00064 BOOL <a class="code" href="musepack_8h.html#a17">mpc_decoder_seek_sample</a>(mpc_decoder *d, mpc_int64_t destsample);
00065 <span class="keywordtype">void</span> mpc_decoder_requantisierung(mpc_decoder *d, <span class="keyword">const</span> mpc_int32_t Last_Band);
00066 
00067 <span class="comment">//------------------------------------------------------------------------------</span>
00068 <span class="comment">// utility functions</span>
00069 <span class="comment">//------------------------------------------------------------------------------</span>
00070 <span class="keyword">static</span> mpc_int32_t f_read(mpc_decoder *d, <span class="keywordtype">void</span> *ptr, size_t size) 
00071 { 
00072     <span class="keywordflow">return</span> d-&gt;r-&gt;read(d-&gt;r-&gt;data, ptr, size); 
00073 };
00074 
00075 <span class="keyword">static</span> BOOL f_seek(mpc_decoder *d, mpc_int32_t offset) 
00076 { 
00077     <span class="keywordflow">return</span> d-&gt;r-&gt;seek(d-&gt;r-&gt;data, offset); 
00078 };
00079 
00080 <span class="keyword">static</span> mpc_int32_t f_read_dword(mpc_decoder *d, mpc_uint32_t * ptr, mpc_uint32_t count) 
00081 {
00082     count = f_read(d, ptr, count &lt;&lt; 2) &gt;&gt; 2;
00083 <span class="preprocessor">#ifndef MPC_LITTLE_ENDIAN</span>
00084 <span class="preprocessor"></span>    mpc_uint32_t n;
00085     <span class="keywordflow">for</span>(n = 0; n&lt; count; n++) {
00086         ptr[n] = swap32(ptr[n]);
00087     }
00088 <span class="preprocessor">#endif</span>
00089 <span class="preprocessor"></span>    <span class="keywordflow">return</span> count;
00090 }
00091 
00092 <span class="comment">//------------------------------------------------------------------------------</span>
00093 <span class="comment">// huffman &amp; bitstream functions</span>
00094 <span class="comment">//------------------------------------------------------------------------------</span>
00095 <span class="keyword">static</span> <span class="keyword">const</span> mpc_uint32_t mask [33] = {
00096     0x00000000, 0x00000001, 0x00000003, 0x00000007,
00097     0x0000000F, 0x0000001F, 0x0000003F, 0x0000007F,
00098     0x000000FF, 0x000001FF, 0x000003FF, 0x000007FF,
00099     0x00000FFF, 0x00001FFF, 0x00003FFF, 0x00007FFF,
00100     0x0000FFFF, 0x0001FFFF, 0x0003FFFF, 0x0007FFFF,
00101     0x000FFFFF, 0x001FFFFF, 0x003FFFFF, 0x007FFFFF,
00102     0x00FFFFFF, 0x01FFFFFF, 0x03FFFFFF, 0x07FFFFFF,
00103     0x0FFFFFFF, 0x1FFFFFFF, 0x3FFFFFFF, 0x7FFFFFFF,
00104     0xFFFFFFFF
00105 };
00106 
00107 <span class="comment">/* F U N C T I O N S */</span>
00108 
00109 <span class="comment">// resets bitstream decoding</span>
00110 <span class="keyword">static</span> <span class="keywordtype">void</span>
00111 mpc_decoder_reset_bitstream_decode(mpc_decoder *d) 
00112 {
00113     d-&gt;dword = 0;
00114     d-&gt;pos = 0;
00115     d-&gt;Zaehler = 0;
00116     d-&gt;WordsRead = 0;
00117 }
00118 
00119 <span class="comment">// reports the number of read bits</span>
00120 <span class="keyword">static</span> mpc_uint32_t
00121 mpc_decoder_bits_read(mpc_decoder *d) 
00122 {
00123     <span class="keywordflow">return</span> 32 * d-&gt;WordsRead + d-&gt;pos;
00124 }
00125 
00126 <span class="comment">// read desired number of bits out of the bitstream</span>
00127 <span class="keyword">static</span> mpc_uint32_t
00128 mpc_decoder_bitstream_read(mpc_decoder *d, <span class="keyword">const</span> mpc_uint32_t bits) 
00129 {
00130     mpc_uint32_t out = d-&gt;dword;
00131 
00132     d-&gt;pos += bits;
00133 
00134     <span class="keywordflow">if</span> (d-&gt;pos &lt; 32) {
00135         out &gt;&gt;= (32 - d-&gt;pos);
00136     }
00137     <span class="keywordflow">else</span> {
00138         d-&gt;dword = d-&gt;Speicher[d-&gt;Zaehler = (d-&gt;Zaehler + 1) &amp; MEMMASK];
00139         d-&gt;pos -= 32;
00140         <span class="keywordflow">if</span> (d-&gt;pos) {
00141             out &lt;&lt;= d-&gt;pos;
00142             out |= d-&gt;dword &gt;&gt; (32 - d-&gt;pos);
00143         }
00144         ++(d-&gt;WordsRead);
00145     }
00146 
00147     <span class="keywordflow">return</span> out &amp; mask[bits];
00148 }
00149 
00150 <span class="comment">// decode SCFI-bundle (sv4,5,6)</span>
00151 <span class="keyword">static</span> <span class="keywordtype">void</span>
00152 mpc_decoder_scfi_bundle_read(
00153     mpc_decoder *d,
00154     <a class="code" href="structhuffman__type__t.html">HuffmanTyp</a>* Table, mpc_int32_t* SCFI, mpc_int32_t* DSCF) 
00155 {
00156     <span class="comment">// load preview and decode</span>
00157     mpc_uint32_t code  = d-&gt;dword &lt;&lt; d-&gt;pos;
00158     <span class="keywordflow">if</span> (d-&gt;pos &gt; 26) {
00159         code |= d-&gt;Speicher[(d-&gt;Zaehler + 1) &amp; MEMMASK] &gt;&gt; (32 - d-&gt;pos);
00160     }
00161     <span class="keywordflow">while</span> (code &lt; Table-&gt;Code) {
00162         Table++;
00163     }
00164 
00165     <span class="comment">// set the new position within bitstream without performing a dummy-read</span>
00166     <span class="keywordflow">if</span> ((d-&gt;pos += Table-&gt;Length) &gt;= 32) {
00167         d-&gt;pos -= 32;
00168         d-&gt;dword = d-&gt;Speicher[d-&gt;Zaehler = (d-&gt;Zaehler+1) &amp; MEMMASK];
00169         ++(d-&gt;WordsRead);
00170     }
00171 
00172     *SCFI = Table-&gt;Value &gt;&gt; 1;
00173     *DSCF = Table-&gt;Value &amp;  1;
00174 }
00175 
00176 <span class="keyword">static</span> <span class="keywordtype">int</span>
00177 mpc_decoder_huffman_typ_cmpfn(<span class="keyword">const</span> <span class="keywordtype">void</span>* p1, <span class="keyword">const</span> <span class="keywordtype">void</span>* p2)
00178 {
00179     <span class="keywordflow">if</span> (((<a class="code" href="structhuffman__type__t.html">HuffmanTyp</a>*) p1)-&gt;Code &lt; ((HuffmanTyp*) p2)-&gt;Code ) <span class="keywordflow">return</span> +1;
00180     <span class="keywordflow">if</span> (((<a class="code" href="structhuffman__type__t.html">HuffmanTyp</a>*) p1)-&gt;Code &gt; ((<a class="code" href="structhuffman__type__t.html">HuffmanTyp</a>*) p2)-&gt;Code ) return -1;
00181     return 0;
00182 }
00183 
00184 <span class="comment">// sort huffman-tables by codeword</span>
00185 <span class="comment">// offset resulting value</span>
00186 <span class="keywordtype">void</span>
<a name="l00187"></a><a class="code" href="mpc__decoder_8c.html#a23">00187</a> mpc_decoder_resort_huff_tables(
00188     const mpc_uint32_t elements, <a class="code" href="structhuffman__type__t.html">HuffmanTyp</a>* Table, const mpc_int32_t offset ) 
00189 {
00190     mpc_uint32_t  i;
00191 
00192     <span class="keywordflow">for</span> ( i = 0; i &lt; elements; i++ ) {
00193         Table[i].Code &lt;&lt;= 32 - Table[i].Length;
00194         Table[i].Value  =  i - offset;
00195     }
00196     qsort(Table, elements, <span class="keyword">sizeof</span>(*Table), mpc_decoder_huffman_typ_cmpfn);
00197 }
00198 
00199 <span class="comment">// basic huffman decoding routine</span>
00200 <span class="comment">// works with maximum lengths up to 14</span>
00201 <span class="keyword">static</span> mpc_int32_t
00202 mpc_decoder_huffman_decode(mpc_decoder *d, <span class="keyword">const</span> <a class="code" href="structhuffman__type__t.html">HuffmanTyp</a> *Table) 
00203 {
00204     <span class="comment">// load preview and decode</span>
00205     mpc_uint32_t code = d-&gt;dword &lt;&lt; d-&gt;pos;
00206     <span class="keywordflow">if</span> (d-&gt;pos &gt; 18) {
00207         code |= d-&gt;Speicher[(d-&gt;Zaehler + 1) &amp; MEMMASK] &gt;&gt; (32 - d-&gt;pos);
00208     }
00209     <span class="keywordflow">while</span> (code &lt; Table-&gt;Code) {
00210         Table++;
00211     }
00212 
00213     <span class="comment">// set the new position within bitstream without performing a dummy-read</span>
00214     <span class="keywordflow">if</span> ((d-&gt;pos += Table-&gt;Length) &gt;= 32) {
00215         d-&gt;pos -= 32;
00216         d-&gt;dword = d-&gt;Speicher[d-&gt;Zaehler = (d-&gt;Zaehler + 1) &amp; MEMMASK];
00217         ++(d-&gt;WordsRead);
00218     }
00219 
00220     <span class="keywordflow">return</span> Table-&gt;Value;
00221 }
00222 
00223 <span class="comment">// faster huffman through previewing less bits</span>
00224 <span class="comment">// works with maximum lengths up to 10</span>
00225 <span class="keyword">static</span> mpc_int32_t
00226 mpc_decoder_huffman_decode_fast(mpc_decoder *d, <span class="keyword">const</span> <a class="code" href="structhuffman__type__t.html">HuffmanTyp</a>* Table)
00227 {
00228     <span class="comment">// load preview and decode</span>
00229     mpc_uint32_t code  = d-&gt;dword &lt;&lt; d-&gt;pos;
00230     <span class="keywordflow">if</span> (d-&gt;pos &gt; 22) {
00231         code |= d-&gt;Speicher[(d-&gt;Zaehler + 1) &amp; MEMMASK] &gt;&gt; (32 - d-&gt;pos);
00232     }
00233     <span class="keywordflow">while</span> (code &lt; Table-&gt;Code) {
00234         Table++;
00235     }
00236 
00237     <span class="comment">// set the new position within bitstream without performing a dummy-read</span>
00238     <span class="keywordflow">if</span> ((d-&gt;pos += Table-&gt;Length) &gt;= 32) {
00239         d-&gt;pos -= 32;
00240         d-&gt;dword = d-&gt;Speicher[d-&gt;Zaehler = (d-&gt;Zaehler + 1) &amp; MEMMASK];
00241         ++(d-&gt;WordsRead);
00242     }
00243 
00244     <span class="keywordflow">return</span> Table-&gt;Value;
00245 }
00246 
00247 <span class="comment">// even faster huffman through previewing even less bits</span>
00248 <span class="comment">// works with maximum lengths up to 5</span>
00249 <span class="keyword">static</span> mpc_int32_t
00250 mpc_decoder_huffman_decode_faster(mpc_decoder *d, <span class="keyword">const</span> <a class="code" href="structhuffman__type__t.html">HuffmanTyp</a>* Table)
00251 {
00252     <span class="comment">// load preview and decode</span>
00253     mpc_uint32_t code  = d-&gt;dword &lt;&lt; d-&gt;pos;
00254     <span class="keywordflow">if</span> (d-&gt;pos &gt; 27) {
00255         code |= d-&gt;Speicher[(d-&gt;Zaehler + 1) &amp; MEMMASK] &gt;&gt; (32 - d-&gt;pos);
00256     }
00257     <span class="keywordflow">while</span> (code &lt; Table-&gt;Code) {
00258         Table++;
00259     }
00260 
00261     <span class="comment">// set the new position within bitstream without performing a dummy-read</span>
00262     <span class="keywordflow">if</span> ((d-&gt;pos += Table-&gt;Length) &gt;= 32) {
00263         d-&gt;pos -= 32;
00264         d-&gt;dword = d-&gt;Speicher[d-&gt;Zaehler = (d-&gt;Zaehler + 1) &amp; MEMMASK];
00265         ++(d-&gt;WordsRead);
00266     }
00267 
00268     <span class="keywordflow">return</span> Table-&gt;Value;
00269 }
00270 
00271 <span class="keyword">static</span> <span class="keywordtype">void</span>
00272 mpc_decoder_reset_v(mpc_decoder *d) 
00273 {
00274     memset(d-&gt;V_L, 0, <span class="keyword">sizeof</span> d-&gt;V_L);
00275     memset(d-&gt;V_R, 0, <span class="keyword">sizeof</span> d-&gt;V_R);
00276 }
00277 
00278 <span class="keyword">static</span> <span class="keywordtype">void</span>
00279 mpc_decoder_reset_synthesis(mpc_decoder *d) 
00280 {
00281     mpc_decoder_reset_v(d);
00282 }
00283 
00284 <span class="keyword">static</span> <span class="keywordtype">void</span>
00285 mpc_decoder_reset_y(mpc_decoder *d) 
00286 {
00287     memset(d-&gt;Y_L, 0, <span class="keyword">sizeof</span> d-&gt;Y_L);
00288     memset(d-&gt;Y_R, 0, <span class="keyword">sizeof</span> d-&gt;Y_R);
00289 }
00290 
00291 <span class="keyword">static</span> <span class="keywordtype">void</span>
00292 mpc_decoder_reset_globals(mpc_decoder *d) 
00293 {
00294     mpc_decoder_reset_bitstream_decode(d);
00295 
00296     d-&gt;DecodedFrames  = 0;
00297     d-&gt;StreamVersion  = 0;
00298     d-&gt;MS_used        = 0;
00299 
00300     memset(d-&gt;Y_L          , 0, <span class="keyword">sizeof</span> d-&gt;Y_L           );
00301     memset(d-&gt;Y_R          , 0, <span class="keyword">sizeof</span> d-&gt;Y_R           );
00302     memset(d-&gt;SCF_Index_L     , 0, <span class="keyword">sizeof</span> d-&gt;SCF_Index_L      );
00303     memset(d-&gt;SCF_Index_R     , 0, <span class="keyword">sizeof</span> d-&gt;SCF_Index_R      );
00304     memset(d-&gt;Res_L           , 0, <span class="keyword">sizeof</span> d-&gt;Res_L            );
00305     memset(d-&gt;Res_R           , 0, <span class="keyword">sizeof</span> d-&gt;Res_R            );
00306     memset(d-&gt;SCFI_L          , 0, <span class="keyword">sizeof</span> d-&gt;SCFI_L           );
00307     memset(d-&gt;SCFI_R          , 0, <span class="keyword">sizeof</span> d-&gt;SCFI_R           );
00308     memset(d-&gt;DSCF_Flag_L     , 0, <span class="keyword">sizeof</span> d-&gt;DSCF_Flag_L      );
00309     memset(d-&gt;DSCF_Flag_R     , 0, <span class="keyword">sizeof</span> d-&gt;DSCF_Flag_R      );
00310     memset(d-&gt;DSCF_Reference_L, 0, <span class="keyword">sizeof</span> d-&gt;DSCF_Reference_L );
00311     memset(d-&gt;DSCF_Reference_R, 0, <span class="keyword">sizeof</span> d-&gt;DSCF_Reference_R );
00312     memset(d-&gt;Q               , 0, <span class="keyword">sizeof</span> d-&gt;Q                );
00313     memset(d-&gt;MS_Flag         , 0, <span class="keyword">sizeof</span> d-&gt;MS_Flag          );
00314 }
00315 
00316 <span class="keyword">static</span> mpc_uint32_t
00317 mpc_decoder_decode_internal(mpc_decoder *d, MPC_SAMPLE_FORMAT *buffer) 
00318 {
00319     mpc_uint32_t output_frame_length = MPC_FRAME_LENGTH;
00320 
00321     mpc_uint32_t  FrameBitCnt = 0;
00322 
00323     <span class="keywordflow">if</span> (d-&gt;DecodedFrames &gt;= d-&gt;OverallFrames) {
00324         <span class="keywordflow">return</span> (mpc_uint32_t)(-1);                           <span class="comment">// end of file -&gt; abort decoding</span>
00325     }
00326 
00327     <span class="comment">// read jump-info for validity check of frame</span>
00328     d-&gt;FwdJumpInfo  = mpc_decoder_bitstream_read(d, 20);
00329 
00330     d-&gt;ActDecodePos = (d-&gt;Zaehler &lt;&lt; 5) + d-&gt;pos;
00331 
00332     <span class="comment">// decode data and check for validity of frame</span>
00333     FrameBitCnt = mpc_decoder_bits_read(d);
00334     <span class="keywordflow">switch</span> (d-&gt;StreamVersion) {
00335     <span class="keywordflow">case</span> 0x04:
00336     <span class="keywordflow">case</span> 0x05:
00337     <span class="keywordflow">case</span> 0x06:
00338         mpc_decoder_read_bitstream_sv6(d);
00339         <span class="keywordflow">break</span>;
00340     <span class="keywordflow">case</span> 0x07:
00341     <span class="keywordflow">case</span> 0x17:
00342         mpc_decoder_read_bitstream_sv7(d);
00343         <span class="keywordflow">break</span>;
00344     <span class="keywordflow">default</span>:
00345         <span class="keywordflow">return</span> (mpc_uint32_t)(-1);
00346     }
00347     d-&gt;FrameWasValid = mpc_decoder_bits_read(d) - FrameBitCnt == d-&gt;FwdJumpInfo;
00348 
00349     <span class="comment">// synthesize signal</span>
00350     mpc_decoder_requantisierung(d, d-&gt;Max_Band);
00351 
00352     <span class="comment">//if ( d-&gt;EQ_activated &amp;&amp; PluginSettings.EQbyMPC )</span>
00353     <span class="comment">//    perform_EQ ();</span>
00354 
00355     mpc_decoder_synthese_filter_float(d, buffer);
00356 
00357     d-&gt;DecodedFrames++;
00358 
00359     <span class="comment">// cut off first MPC_DECODER_SYNTH_DELAY zero-samples</span>
00360     <span class="keywordflow">if</span> (d-&gt;DecodedFrames == d-&gt;OverallFrames  &amp;&amp; d-&gt;StreamVersion &gt;= 6) {        
00361         <span class="comment">// reconstruct exact filelength</span>
00362         mpc_int32_t  mod_block   = mpc_decoder_bitstream_read(d,  11);
00363         mpc_int32_t  FilterDecay;
00364 
00365         <span class="keywordflow">if</span> (mod_block == 0) {
00366             <span class="comment">// Encoder bugfix</span>
00367             mod_block = 1152;                    
00368         }
00369         FilterDecay = (mod_block + MPC_DECODER_SYNTH_DELAY) % MPC_FRAME_LENGTH;
00370 
00371         <span class="comment">// additional FilterDecay samples are needed for decay of synthesis filter</span>
00372         <span class="keywordflow">if</span> (MPC_DECODER_SYNTH_DELAY + mod_block &gt;= MPC_FRAME_LENGTH) {
00373 
00374             <span class="comment">// **********************************************************************</span>
00375             <span class="comment">// Rhoades 4/16/2002</span>
00376             <span class="comment">// Commented out are blocks of code which cause gapless playback to fail.</span>
00377             <span class="comment">// Temporary fix...</span>
00378             <span class="comment">// **********************************************************************</span>
00379 
00380             <span class="keywordflow">if</span> (!d-&gt;TrueGaplessPresent) {
00381                 mpc_decoder_reset_y(d);
00382             } 
00383             <span class="keywordflow">else</span> {
00384                 <span class="comment">//if ( MPC_FRAME_LENGTH != d-&gt;LastValidSamples ) {</span>
00385                 mpc_decoder_bitstream_read(d, 20);
00386                 mpc_decoder_read_bitstream_sv7(d);
00387                 mpc_decoder_requantisierung(d, d-&gt;Max_Band);
00388                 <span class="comment">//FilterDecay = d-&gt;LastValidSamples;</span>
00389                 <span class="comment">//}</span>
00390                 <span class="comment">//else {</span>
00391                 <span class="comment">//FilterDecay = 0;</span>
00392                 <span class="comment">//}</span>
00393             }
00394 
00395             mpc_decoder_synthese_filter_float(d, buffer + 2304);
00396 
00397             output_frame_length = MPC_FRAME_LENGTH + FilterDecay;
00398         }
00399         <span class="keywordflow">else</span> {                              <span class="comment">// there are only FilterDecay samples needed for this frame</span>
00400             output_frame_length = FilterDecay;
00401         }
00402     }
00403 
00404     <span class="keywordflow">if</span> (d-&gt;samples_to_skip) {
00405         <span class="keywordflow">if</span> (output_frame_length &lt; d-&gt;samples_to_skip) {
00406             d-&gt;samples_to_skip -= output_frame_length;
00407             output_frame_length = 0;
00408         }
00409         <span class="keywordflow">else</span> {
00410             output_frame_length -= d-&gt;samples_to_skip;
00411             memmove(
00412                 buffer, 
00413                 buffer + d-&gt;samples_to_skip * 2, 
00414                 output_frame_length * 2 * sizeof (MPC_SAMPLE_FORMAT));
00415             d-&gt;samples_to_skip = 0;
00416         }
00417     }
00418 
00419     <span class="keywordflow">return</span> output_frame_length;
00420 }
00421 
<a name="l00422"></a><a class="code" href="mpc__decoder_8c.html#a32">00422</a> mpc_uint32_t <a class="code" href="musepack_8h.html#a16">mpc_decoder_decode</a>(
00423     mpc_decoder *d,
00424     MPC_SAMPLE_FORMAT *buffer, 
00425     mpc_uint32_t *vbr_update_acc, 
00426     mpc_uint32_t *vbr_update_bits)
00427 {
00428     <span class="keywordflow">for</span>(;;)
00429     {
00430         <span class="comment">//const mpc_int32_t MaxBrokenFrames = 0; // PluginSettings.MaxBrokenFrames</span>
00431 
00432         mpc_uint32_t RING = d-&gt;Zaehler;
00433         mpc_int32_t vbr_ring = (RING &lt;&lt; 5) + d-&gt;pos;
00434 
00435         mpc_uint32_t valid_samples = mpc_decoder_decode_internal(d, buffer);
00436 
00437         <span class="keywordflow">if</span> (valid_samples == (mpc_uint32_t)(-1) ) {
00438             <span class="keywordflow">return</span> 0;
00439         }
00440 
00441         <span class="comment">/**************** ERROR CONCEALMENT *****************/</span>
00442         <span class="keywordflow">if</span> (d-&gt;FrameWasValid == 0 ) {
00443             <span class="comment">// error occurred in bitstream</span>
00444             <span class="keywordflow">return</span> (mpc_uint32_t)(-1);
00445         } 
00446         <span class="keywordflow">else</span> {
00447             <span class="keywordflow">if</span> (vbr_update_acc &amp;&amp; vbr_update_bits) {
00448                 (*vbr_update_acc) ++;
00449                 vbr_ring = (d-&gt;Zaehler &lt;&lt; 5) + d-&gt;pos - vbr_ring;
00450                 <span class="keywordflow">if</span> (vbr_ring &lt; 0) {
00451                     vbr_ring += 524288;
00452                 }
00453                 (*vbr_update_bits) += vbr_ring;
00454             }
00455 
00456         }
00457         mpc_decoder_update_buffer(d, RING);
00458 
00459         <span class="keywordflow">if</span> (valid_samples &gt; 0) {
00460             <span class="keywordflow">return</span> valid_samples;
00461         }
00462     }
00463 }
00464 
00465 <span class="keywordtype">void</span>
00466 mpc_decoder_requantisierung(mpc_decoder *d, <span class="keyword">const</span> mpc_int32_t Last_Band) 
00467 {
00468     mpc_int32_t     Band;
00469     mpc_int32_t     n;
00470     MPC_SAMPLE_FORMAT facL;
00471     MPC_SAMPLE_FORMAT facR;
00472     MPC_SAMPLE_FORMAT templ;
00473     MPC_SAMPLE_FORMAT tempr;
00474     MPC_SAMPLE_FORMAT* YL;
00475     MPC_SAMPLE_FORMAT* YR;
00476     mpc_int32_t*    L;
00477     mpc_int32_t*    R;
00478 
00479 <span class="preprocessor">#ifdef MPC_FIXED_POINT</span>
00480 <span class="preprocessor"></span><span class="preprocessor">#if MPC_FIXED_POINT_FRACTPART == 14</span>
00481 <span class="preprocessor"></span><span class="preprocessor">#define MPC_MULTIPLY_SCF(CcVal, SCF_idx) \</span>
00482 <span class="preprocessor">    MPC_MULTIPLY_EX(CcVal, d-&gt;SCF[SCF_idx], d-&gt;SCF_shift[SCF_idx])</span>
00483 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00484 <span class="preprocessor"></span>
00485 <span class="preprocessor">#error FIXME, Cc table is in 18.14 format</span>
00486 <span class="preprocessor"></span>
00487 <span class="preprocessor">#endif</span>
00488 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00489 <span class="preprocessor"></span><span class="preprocessor">#define MPC_MULTIPLY_SCF(CcVal, SCF_idx) \</span>
00490 <span class="preprocessor">    MPC_MULTIPLY(CcVal, d-&gt;SCF[SCF_idx])</span>
00491 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00492 <span class="preprocessor"></span>    <span class="comment">// requantization and scaling of subband-samples</span>
00493     <span class="keywordflow">for</span> ( Band = 0; Band &lt;= Last_Band; Band++ ) {   <span class="comment">// setting pointers</span>
00494         YL = d-&gt;Y_L[0] + Band;
00495         YR = d-&gt;Y_R[0] + Band;
00496         L  = d-&gt;Q[Band].L;
00497         R  = d-&gt;Q[Band].R;
00498         <span class="comment">/************************** MS-coded **************************/</span>
00499         <span class="keywordflow">if</span> ( d-&gt;MS_Flag [Band] ) {
00500             <span class="keywordflow">if</span> ( d-&gt;Res_L [Band] ) {
00501                 <span class="keywordflow">if</span> ( d-&gt;Res_R [Band] ) {    <span class="comment">// M!=0, S!=0</span>
00502                     facL = MPC_MULTIPLY_SCF( Cc[d-&gt;Res_L[Band]] , (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)d-&gt;SCF_Index_L[Band][0]);
00503                     facR = MPC_MULTIPLY_SCF( Cc[d-&gt;Res_R[Band]] , (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)d-&gt;SCF_Index_R[Band][0]);
00504                     <span class="keywordflow">for</span> ( n = 0; n &lt; 12; n++, YL += 32, YR += 32 ) {
00505                         *YL   = (templ = MPC_MULTIPLY_FLOAT_INT(facL,*L++))+(tempr = MPC_MULTIPLY_FLOAT_INT(facR,*R++));
00506                         *YR   = templ - tempr;
00507                     }
00508                     facL = MPC_MULTIPLY_SCF( Cc[d-&gt;Res_L[Band]] , (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)d-&gt;SCF_Index_L[Band][1]);
00509                     facR = MPC_MULTIPLY_SCF( Cc[d-&gt;Res_R[Band]] , (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)d-&gt;SCF_Index_R[Band][1]);
00510                     <span class="keywordflow">for</span> ( ; n &lt; 24; n++, YL += 32, YR += 32 ) {
00511                         *YL   = (templ = MPC_MULTIPLY_FLOAT_INT(facL,*L++))+(tempr = MPC_MULTIPLY_FLOAT_INT(facR,*R++));
00512                         *YR   = templ - tempr;
00513                     }
00514                     facL = MPC_MULTIPLY_SCF( Cc[d-&gt;Res_L[Band]] , (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)d-&gt;SCF_Index_L[Band][2]);
00515                     facR = MPC_MULTIPLY_SCF( Cc[d-&gt;Res_R[Band]] , (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)d-&gt;SCF_Index_R[Band][2]);
00516                     <span class="keywordflow">for</span> ( ; n &lt; 36; n++, YL += 32, YR += 32 ) {
00517                         *YL   = (templ = MPC_MULTIPLY_FLOAT_INT(facL,*L++))+(tempr = MPC_MULTIPLY_FLOAT_INT(facR,*R++));
00518                         *YR   = templ - tempr;
00519                     }
00520                 } <span class="keywordflow">else</span> {    <span class="comment">// M!=0, S==0</span>
00521                     facL = MPC_MULTIPLY_SCF( Cc[d-&gt;Res_L[Band]] , (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)d-&gt;SCF_Index_L[Band][0]);
00522                     <span class="keywordflow">for</span> ( n = 0; n &lt; 12; n++, YL += 32, YR += 32 ) {
00523                         *YR = *YL = MPC_MULTIPLY_FLOAT_INT(facL,*L++);
00524                     }
00525                     facL = MPC_MULTIPLY_SCF( Cc[d-&gt;Res_L[Band]] , (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)d-&gt;SCF_Index_L[Band][1]);
00526                     <span class="keywordflow">for</span> ( ; n &lt; 24; n++, YL += 32, YR += 32 ) {
00527                         *YR = *YL = MPC_MULTIPLY_FLOAT_INT(facL,*L++);
00528                     }
00529                     facL = MPC_MULTIPLY_SCF( Cc[d-&gt;Res_L[Band]] , (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)d-&gt;SCF_Index_L[Band][2]);
00530                     <span class="keywordflow">for</span> ( ; n &lt; 36; n++, YL += 32, YR += 32 ) {
00531                         *YR = *YL = MPC_MULTIPLY_FLOAT_INT(facL,*L++);
00532                     }
00533                 }
00534             } <span class="keywordflow">else</span> {
00535                 <span class="keywordflow">if</span> (d-&gt;Res_R[Band])    <span class="comment">// M==0, S!=0</span>
00536                 {
00537                     facR = MPC_MULTIPLY_SCF( Cc[d-&gt;Res_R[Band]] , (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)d-&gt;SCF_Index_R[Band][0]);
00538                     <span class="keywordflow">for</span> ( n = 0; n &lt; 12; n++, YL += 32, YR += 32 ) {
00539                         *YR = - (*YL = MPC_MULTIPLY_FLOAT_INT(facR,*(R++)));
00540                     }
00541                     facR = MPC_MULTIPLY_SCF( Cc[d-&gt;Res_R[Band]] , (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)d-&gt;SCF_Index_R[Band][1]);
00542                     <span class="keywordflow">for</span> ( ; n &lt; 24; n++, YL += 32, YR += 32 ) {
00543                         *YR = - (*YL = MPC_MULTIPLY_FLOAT_INT(facR,*(R++)));
00544                     }
00545                     facR = MPC_MULTIPLY_SCF( Cc[d-&gt;Res_R[Band]] , (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)d-&gt;SCF_Index_R[Band][2]);
00546                     <span class="keywordflow">for</span> ( ; n &lt; 36; n++, YL += 32, YR += 32 ) {
00547                         *YR = - (*YL = MPC_MULTIPLY_FLOAT_INT(facR,*(R++)));
00548                     }
00549                 } <span class="keywordflow">else</span> {    <span class="comment">// M==0, S==0</span>
00550                     <span class="keywordflow">for</span> ( n = 0; n &lt; 36; n++, YL += 32, YR += 32 ) {
00551                         *YR = *YL = 0;
00552                     }
00553                 }
00554             }
00555         }
00556         <span class="comment">/************************** LR-coded **************************/</span>
00557         <span class="keywordflow">else</span> {
00558             <span class="keywordflow">if</span> ( d-&gt;Res_L [Band] ) {
00559                 <span class="keywordflow">if</span> ( d-&gt;Res_R [Band] ) {    <span class="comment">// L!=0, R!=0</span>
00560                     facL = MPC_MULTIPLY_SCF( Cc[d-&gt;Res_L[Band]] , (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)d-&gt;SCF_Index_L[Band][0]);
00561                     facR = MPC_MULTIPLY_SCF( Cc[d-&gt;Res_R[Band]] , (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)d-&gt;SCF_Index_R[Band][0]);
00562                     <span class="keywordflow">for</span> (n = 0; n &lt; 12; n++, YL += 32, YR += 32 ) {
00563                         *YL = MPC_MULTIPLY_FLOAT_INT(facL,*L++);
00564                         *YR = MPC_MULTIPLY_FLOAT_INT(facR,*R++);
00565                     }
00566                     facL = MPC_MULTIPLY_SCF( Cc[d-&gt;Res_L[Band]] , (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)d-&gt;SCF_Index_L[Band][1]);
00567                     facR = MPC_MULTIPLY_SCF( Cc[d-&gt;Res_R[Band]] , (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)d-&gt;SCF_Index_R[Band][1]);
00568                     <span class="keywordflow">for</span> (; n &lt; 24; n++, YL += 32, YR += 32 ) {
00569                         *YL = MPC_MULTIPLY_FLOAT_INT(facL,*L++);
00570                         *YR = MPC_MULTIPLY_FLOAT_INT(facR,*R++);
00571                     }
00572                     facL = MPC_MULTIPLY_SCF( Cc[d-&gt;Res_L[Band]] , (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)d-&gt;SCF_Index_L[Band][2]);
00573                     facR = MPC_MULTIPLY_SCF( Cc[d-&gt;Res_R[Band]] , (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)d-&gt;SCF_Index_R[Band][2]);
00574                     <span class="keywordflow">for</span> (; n &lt; 36; n++, YL += 32, YR += 32 ) {
00575                         *YL = MPC_MULTIPLY_FLOAT_INT(facL,*L++);
00576                         *YR = MPC_MULTIPLY_FLOAT_INT(facR,*R++);
00577                     }
00578                 } <span class="keywordflow">else</span> {     <span class="comment">// L!=0, R==0</span>
00579                     facL = MPC_MULTIPLY_SCF( Cc[d-&gt;Res_L[Band]] , (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)d-&gt;SCF_Index_L[Band][0]);
00580                     <span class="keywordflow">for</span> ( n = 0; n &lt; 12; n++, YL += 32, YR += 32 ) {
00581                         *YL = MPC_MULTIPLY_FLOAT_INT(facL,*L++);
00582                         *YR = 0;
00583                     }
00584                     facL = MPC_MULTIPLY_SCF( Cc[d-&gt;Res_L[Band]] , (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)d-&gt;SCF_Index_L[Band][1]);
00585                     <span class="keywordflow">for</span> ( ; n &lt; 24; n++, YL += 32, YR += 32 ) {
00586                         *YL = MPC_MULTIPLY_FLOAT_INT(facL,*L++);
00587                         *YR = 0;
00588                     }
00589                     facL = MPC_MULTIPLY_SCF( Cc[d-&gt;Res_L[Band]] , (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)d-&gt;SCF_Index_L[Band][2]);
00590                     <span class="keywordflow">for</span> ( ; n &lt; 36; n++, YL += 32, YR += 32 ) {
00591                         *YL = MPC_MULTIPLY_FLOAT_INT(facL,*L++);
00592                         *YR = 0;
00593                     }
00594                 }
00595             }
00596             <span class="keywordflow">else</span> {
00597                 <span class="keywordflow">if</span> ( d-&gt;Res_R [Band] ) {    <span class="comment">// L==0, R!=0</span>
00598                     facR = MPC_MULTIPLY_SCF( Cc[d-&gt;Res_R[Band]] , (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)d-&gt;SCF_Index_R[Band][0]);
00599                     <span class="keywordflow">for</span> ( n = 0; n &lt; 12; n++, YL += 32, YR += 32 ) {
00600                         *YL = 0;
00601                         *YR = MPC_MULTIPLY_FLOAT_INT(facR,*R++);
00602                     }
00603                     facR = MPC_MULTIPLY_SCF( Cc[d-&gt;Res_R[Band]] , (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)d-&gt;SCF_Index_R[Band][1]);
00604                     <span class="keywordflow">for</span> ( ; n &lt; 24; n++, YL += 32, YR += 32 ) {
00605                         *YL = 0;
00606                         *YR = MPC_MULTIPLY_FLOAT_INT(facR,*R++);
00607                     }
00608                     facR = MPC_MULTIPLY_SCF( Cc[d-&gt;Res_R[Band]] , (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)d-&gt;SCF_Index_R[Band][2]);
00609                     <span class="keywordflow">for</span> ( ; n &lt; 36; n++, YL += 32, YR += 32 ) {
00610                         *YL = 0;
00611                         *YR = MPC_MULTIPLY_FLOAT_INT(facR,*R++);
00612                     }
00613                 } <span class="keywordflow">else</span> {    <span class="comment">// L==0, R==0</span>
00614                     <span class="keywordflow">for</span> ( n = 0; n &lt; 36; n++, YL += 32, YR += 32 ) {
00615                         *YR = *YL = 0;
00616                     }
00617                 }
00618             }
00619         }
00620     }
00621 }
00622 
00623 <span class="comment">/****************************************** SV 6 ******************************************/</span>
00624 <span class="keywordtype">void</span>
00625 mpc_decoder_read_bitstream_sv6(mpc_decoder *d) 
00626 {
00627     mpc_int32_t n,k;
00628     mpc_int32_t Max_used_Band=0;
00629     <a class="code" href="structhuffman__type__t.html">HuffmanTyp</a> *Table;
00630     <span class="keyword">const</span> <a class="code" href="structhuffman__type__t.html">HuffmanTyp</a> *x1;
00631     <span class="keyword">const</span> <a class="code" href="structhuffman__type__t.html">HuffmanTyp</a> *x2;
00632     mpc_int32_t *L;
00633     mpc_int32_t *R;
00634     mpc_int32_t *ResL = d-&gt;Res_L;
00635     mpc_int32_t *ResR = d-&gt;Res_R;
00636 
00637     <span class="comment">/************************ HEADER **************************/</span>
00638     ResL = d-&gt;Res_L;
00639     ResR = d-&gt;Res_R;
00640     <span class="keywordflow">for</span> (n=0; n &lt;= d-&gt;Max_Band; ++n, ++ResL, ++ResR)
00641     {
00642         <span class="keywordflow">if</span>      (n&lt;11)           Table = d-&gt;Region_A;
00643         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (n&gt;=11 &amp;&amp; n&lt;=22) Table = d-&gt;Region_B;
00644         <span class="keywordflow">else</span> <span class="comment">/*if (n&gt;=23)*/</span>      Table = d-&gt;Region_C;
00645 
00646         *ResL = d-&gt;Q_res[n][mpc_decoder_huffman_decode(d, Table)];
00647         <span class="keywordflow">if</span> (d-&gt;MS_used) {
00648             d-&gt;MS_Flag[n] = mpc_decoder_bitstream_read(d,  1);
00649         }
00650         *ResR = d-&gt;Q_res[n][mpc_decoder_huffman_decode(d, Table)];
00651 
00652         <span class="comment">// only perform the following procedure up to the maximum non-zero subband</span>
00653         <span class="keywordflow">if</span> (*ResL || *ResR) Max_used_Band = n;
00654     }
00655 
00656     <span class="comment">/************************* SCFI-Bundle *****************************/</span>
00657     ResL = d-&gt;Res_L;
00658     ResR = d-&gt;Res_R;
00659     for (n=0; n&lt;=Max_used_Band; ++n, ++ResL, ++ResR) {
00660         <span class="keywordflow">if</span> (*ResL) mpc_decoder_scfi_bundle_read(d, d-&gt;SCFI_Bundle, &amp;(d-&gt;SCFI_L[n]), &amp;(d-&gt;DSCF_Flag_L[n]));
00661         if (*ResR) mpc_decoder_scfi_bundle_read(d, d-&gt;SCFI_Bundle, &amp;(d-&gt;SCFI_R[n]), &amp;(d-&gt;DSCF_Flag_R[n]));
00662     }
00663 
00664     <span class="comment">/***************************** SCFI ********************************/</span>
00665     ResL = d-&gt;Res_L;
00666     ResR = d-&gt;Res_R;
00667     L    = d-&gt;SCF_Index_L[0];
00668     R    = d-&gt;SCF_Index_R[0];
00669     <span class="keywordflow">for</span> (n=0; n &lt;= Max_used_Band; ++n, ++ResL, ++ResR, L+=3, R+=3)
00670     {
00671         <span class="keywordflow">if</span> (*ResL)
00672         {
00673             <span class="comment">/*********** DSCF ************/</span>
00674             <span class="keywordflow">if</span> (d-&gt;DSCF_Flag_L[n]==1)
00675             {
00676                 L[2] = d-&gt;DSCF_Reference_L[n];
00677                 switch (d-&gt;SCFI_L[n])
00678                 {
00679                 <span class="keywordflow">case</span> 3:
00680                     L[0] = L[2] + mpc_decoder_huffman_decode_fast(d,  d-&gt;DSCF_Entropie);
00681                     L[1] = L[0];
00682                     L[2] = L[1];
00683                     <span class="keywordflow">break</span>;
00684                 <span class="keywordflow">case</span> 1:
00685                     L[0] = L[2] + mpc_decoder_huffman_decode_fast(d,  d-&gt;DSCF_Entropie);
00686                     L[1] = L[0] + mpc_decoder_huffman_decode_fast(d,  d-&gt;DSCF_Entropie);
00687                     L[2] = L[1];
00688                     <span class="keywordflow">break</span>;
00689                 <span class="keywordflow">case</span> 2:
00690                     L[0] = L[2] + mpc_decoder_huffman_decode_fast(d,  d-&gt;DSCF_Entropie);
00691                     L[1] = L[0];
00692                     L[2] = L[1] + mpc_decoder_huffman_decode_fast(d,  d-&gt;DSCF_Entropie);
00693                     <span class="keywordflow">break</span>;
00694                 <span class="keywordflow">case</span> 0:
00695                     L[0] = L[2] + mpc_decoder_huffman_decode_fast(d,  d-&gt;DSCF_Entropie);
00696                     L[1] = L[0] + mpc_decoder_huffman_decode_fast(d,  d-&gt;DSCF_Entropie);
00697                     L[2] = L[1] + mpc_decoder_huffman_decode_fast(d,  d-&gt;DSCF_Entropie);
00698                     <span class="keywordflow">break</span>;
00699                 <span class="keywordflow">default</span>:
00700                     <span class="keywordflow">return</span>;
00701                     <span class="keywordflow">break</span>;
00702                 }
00703             }
00704             <span class="comment">/************ SCF ************/</span>
00705             <span class="keywordflow">else</span>
00706             {
00707                 <span class="keywordflow">switch</span> (d-&gt;SCFI_L[n])
00708                 {
00709                 <span class="keywordflow">case</span> 3:
00710                     L[0] = mpc_decoder_bitstream_read(d,  6);
00711                     L[1] = L[0];
00712                     L[2] = L[1];
00713                     <span class="keywordflow">break</span>;
00714                 <span class="keywordflow">case</span> 1:
00715                     L[0] = mpc_decoder_bitstream_read(d,  6);
00716                     L[1] = mpc_decoder_bitstream_read(d,  6);
00717                     L[2] = L[1];
00718                     <span class="keywordflow">break</span>;
00719                 <span class="keywordflow">case</span> 2:
00720                     L[0] = mpc_decoder_bitstream_read(d,  6);
00721                     L[1] = L[0];
00722                     L[2] = mpc_decoder_bitstream_read(d,  6);
00723                     <span class="keywordflow">break</span>;
00724                 <span class="keywordflow">case</span> 0:
00725                     L[0] = mpc_decoder_bitstream_read(d,  6);
00726                     L[1] = mpc_decoder_bitstream_read(d,  6);
00727                     L[2] = mpc_decoder_bitstream_read(d,  6);
00728                     <span class="keywordflow">break</span>;
00729                 <span class="keywordflow">default</span>:
00730                     <span class="keywordflow">return</span>;
00731                     <span class="keywordflow">break</span>;
00732                 }
00733             }
00734             <span class="comment">// update Reference for DSCF</span>
00735             d-&gt;DSCF_Reference_L[n] = L[2];
00736         }
00737         <span class="keywordflow">if</span> (*ResR)
00738         {
00739             R[2] = d-&gt;DSCF_Reference_R[n];
00740             <span class="comment">/*********** DSCF ************/</span>
00741             if (d-&gt;DSCF_Flag_R[n]==1)
00742             {
00743                 switch (d-&gt;SCFI_R[n])
00744                 {
00745                 <span class="keywordflow">case</span> 3:
00746                     R[0] = R[2] + mpc_decoder_huffman_decode_fast(d,  d-&gt;DSCF_Entropie);
00747                     R[1] = R[0];
00748                     R[2] = R[1];
00749                     <span class="keywordflow">break</span>;
00750                 <span class="keywordflow">case</span> 1:
00751                     R[0] = R[2] + mpc_decoder_huffman_decode_fast(d,  d-&gt;DSCF_Entropie);
00752                     R[1] = R[0] + mpc_decoder_huffman_decode_fast(d,  d-&gt;DSCF_Entropie);
00753                     R[2] = R[1];
00754                     <span class="keywordflow">break</span>;
00755                 <span class="keywordflow">case</span> 2:
00756                     R[0] = R[2] + mpc_decoder_huffman_decode_fast(d,  d-&gt;DSCF_Entropie);
00757                     R[1] = R[0];
00758                     R[2] = R[1] + mpc_decoder_huffman_decode_fast(d,  d-&gt;DSCF_Entropie);
00759                     <span class="keywordflow">break</span>;
00760                 <span class="keywordflow">case</span> 0:
00761                     R[0] = R[2] + mpc_decoder_huffman_decode_fast(d,  d-&gt;DSCF_Entropie);
00762                     R[1] = R[0] + mpc_decoder_huffman_decode_fast(d,  d-&gt;DSCF_Entropie);
00763                     R[2] = R[1] + mpc_decoder_huffman_decode_fast(d,  d-&gt;DSCF_Entropie);
00764                     <span class="keywordflow">break</span>;
00765                 <span class="keywordflow">default</span>:
00766                     <span class="keywordflow">return</span>;
00767                     <span class="keywordflow">break</span>;
00768                 }
00769             }
00770             <span class="comment">/************ SCF ************/</span>
00771             <span class="keywordflow">else</span>
00772             {
00773                 <span class="keywordflow">switch</span> (d-&gt;SCFI_R[n])
00774                 {
00775                 <span class="keywordflow">case</span> 3:
00776                     R[0] = mpc_decoder_bitstream_read(d, 6);
00777                     R[1] = R[0];
00778                     R[2] = R[1];
00779                     <span class="keywordflow">break</span>;
00780                 <span class="keywordflow">case</span> 1:
00781                     R[0] = mpc_decoder_bitstream_read(d, 6);
00782                     R[1] = mpc_decoder_bitstream_read(d, 6);
00783                     R[2] = R[1];
00784                     <span class="keywordflow">break</span>;
00785                 <span class="keywordflow">case</span> 2:
00786                     R[0] = mpc_decoder_bitstream_read(d, 6);
00787                     R[1] = R[0];
00788                     R[2] = mpc_decoder_bitstream_read(d, 6);
00789                     <span class="keywordflow">break</span>;
00790                 <span class="keywordflow">case</span> 0:
00791                     R[0] = mpc_decoder_bitstream_read(d, 6);
00792                     R[1] = mpc_decoder_bitstream_read(d, 6);
00793                     R[2] = mpc_decoder_bitstream_read(d, 6);
00794                     <span class="keywordflow">break</span>;
00795                 <span class="keywordflow">default</span>:
00796                     <span class="keywordflow">return</span>;
00797                     <span class="keywordflow">break</span>;
00798                 }
00799             }
00800             <span class="comment">// update Reference for DSCF</span>
00801             d-&gt;DSCF_Reference_R[n] = R[2];
00802         }
00803     }
00804 
00805     <span class="comment">/**************************** Samples ****************************/</span>
00806     ResL = d-&gt;Res_L;
00807     ResR = d-&gt;Res_R;
00808     <span class="keywordflow">for</span> (n=0; n &lt;= Max_used_Band; ++n, ++ResL, ++ResR)
00809     {
00810         <span class="comment">// setting pointers</span>
00811         x1 = d-&gt;SampleHuff[*ResL];
00812         x2 = d-&gt;SampleHuff[*ResR];
00813         L = d-&gt;Q[n].L;
00814         R = d-&gt;Q[n].R;
00815 
00816         if (x1!=NULL || x2!=NULL)
00817             <span class="keywordflow">for</span> (k=0; k&lt;36; ++k)
00818             {
00819                 <span class="keywordflow">if</span> (x1 != NULL) *L++ = mpc_decoder_huffman_decode_fast(d,  x1);
00820                 <span class="keywordflow">if</span> (x2 != NULL) *R++ = mpc_decoder_huffman_decode_fast(d,  x2);
00821             }
00822 
00823         <span class="keywordflow">if</span> (*ResL&gt;7 || *ResR&gt;7)
00824             <span class="keywordflow">for</span> (k=0; k&lt;36; ++k)
00825             {
00826                 <span class="keywordflow">if</span> (*ResL&gt;7) *L++ = (mpc_int32_t)mpc_decoder_bitstream_read(d,  Res_bit[*ResL]) - Dc[*ResL];
00827                 <span class="keywordflow">if</span> (*ResR&gt;7) *R++ = (mpc_int32_t)mpc_decoder_bitstream_read(d,  Res_bit[*ResR]) - Dc[*ResR];
00828             }
00829     }
00830 }
00831 
00832 <span class="comment">/****************************************** SV 7 ******************************************/</span>
00833 <span class="keywordtype">void</span>
00834 mpc_decoder_read_bitstream_sv7(mpc_decoder *d) 
00835 {
00836     <span class="comment">// these arrays hold decoding results for bundled quantizers (3- and 5-step)</span>
00837     <span class="comment">/*static*/</span> mpc_int32_t idx30[] = { -1, 0, 1,-1, 0, 1,-1, 0, 1,-1, 0, 1,-1, 0, 1,-1, 0, 1,-1, 0, 1,-1, 0, 1,-1, 0, 1};
00838     <span class="comment">/*static*/</span> mpc_int32_t idx31[] = { -1,-1,-1, 0, 0, 0, 1, 1, 1,-1,-1,-1, 0, 0, 0, 1, 1, 1,-1,-1,-1, 0, 0, 0, 1, 1, 1};
00839     <span class="comment">/*static*/</span> mpc_int32_t idx32[] = { -1,-1,-1,-1,-1,-1,-1,-1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1};
00840     <span class="comment">/*static*/</span> mpc_int32_t idx50[] = { -2,-1, 0, 1, 2,-2,-1, 0, 1, 2,-2,-1, 0, 1, 2,-2,-1, 0, 1, 2,-2,-1, 0, 1, 2};
00841     <span class="comment">/*static*/</span> mpc_int32_t idx51[] = { -2,-2,-2,-2,-2,-1,-1,-1,-1,-1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2};
00842 
00843     mpc_int32_t n,k;
00844     mpc_int32_t Max_used_Band=0;
00845     <span class="keyword">const</span> <a class="code" href="structhuffman__type__t.html">HuffmanTyp</a> *Table;
00846     mpc_int32_t idx;
00847     mpc_int32_t *L   ,*R;
00848     mpc_int32_t *ResL,*ResR;
00849     mpc_uint32_t tmp;
00850 
00851     <span class="comment">/***************************** Header *****************************/</span>
00852     ResL  = d-&gt;Res_L;
00853     ResR  = d-&gt;Res_R;
00854 
00855     <span class="comment">// first subband</span>
00856     *ResL = mpc_decoder_bitstream_read(d, 4);
00857     *ResR = mpc_decoder_bitstream_read(d, 4);
00858     <span class="keywordflow">if</span> (d-&gt;MS_used &amp;&amp; !(*ResL==0 &amp;&amp; *ResR==0)) {
00859         d-&gt;MS_Flag[0] = mpc_decoder_bitstream_read(d, 1);
00860     }
00861 
00862     <span class="comment">// consecutive subbands</span>
00863     ++ResL; ++ResR; <span class="comment">// increase pointers</span>
00864     <span class="keywordflow">for</span> (n=1; n &lt;= d-&gt;Max_Band; ++n, ++ResL, ++ResR)
00865     {
00866         idx   = mpc_decoder_huffman_decode_fast(d, d-&gt;HuffHdr);
00867         *ResL = (idx!=4) ? *(ResL-1) + idx : mpc_decoder_bitstream_read(d, 4);
00868 
00869         idx   = mpc_decoder_huffman_decode_fast(d, d-&gt;HuffHdr);
00870         *ResR = (idx!=4) ? *(ResR-1) + idx : mpc_decoder_bitstream_read(d, 4);
00871 
00872         <span class="keywordflow">if</span> (d-&gt;MS_used &amp;&amp; !(*ResL==0 &amp;&amp; *ResR==0)) {
00873             d-&gt;MS_Flag[n] = mpc_decoder_bitstream_read(d, 1);
00874         }
00875 
00876         <span class="comment">// only perform following procedures up to the maximum non-zero subband</span>
00877         <span class="keywordflow">if</span> (*ResL!=0 || *ResR!=0) {
00878             Max_used_Band = n;
00879         }
00880     }
00881     <span class="comment">/****************************** SCFI ******************************/</span>
00882     L     = d-&gt;SCFI_L;
00883     R     = d-&gt;SCFI_R;
00884     ResL  = d-&gt;Res_L;
00885     ResR  = d-&gt;Res_R;
00886     for (n=0; n &lt;= Max_used_Band; ++n, ++L, ++R, ++ResL, ++ResR) {
00887         <span class="keywordflow">if</span> (*ResL) *L = mpc_decoder_huffman_decode_faster(d, d-&gt;HuffSCFI);
00888         if (*ResR) *R = mpc_decoder_huffman_decode_faster(d, d-&gt;HuffSCFI);
00889     }
00890 
00891     <span class="comment">/**************************** SCF/DSCF ****************************/</span>
00892     ResL  = d-&gt;Res_L;
00893     ResR  = d-&gt;Res_R;
00894     L     = d-&gt;SCF_Index_L[0];
00895     R     = d-&gt;SCF_Index_R[0];
00896     <span class="keywordflow">for</span> (n=0; n&lt;=Max_used_Band; ++n, ++ResL, ++ResR, L+=3, R+=3) {
00897         <span class="keywordflow">if</span> (*ResL)
00898         {
00899             L[2] = d-&gt;DSCF_Reference_L[n];
00900             switch (d-&gt;SCFI_L[n])
00901             {
00902             <span class="keywordflow">case</span> 1:
00903                 idx  = mpc_decoder_huffman_decode_fast(d, d-&gt;HuffDSCF);
00904                 L[0] = (idx!=8) ? L[2] + idx : mpc_decoder_bitstream_read(d, 6);
00905                 idx  = mpc_decoder_huffman_decode_fast(d, d-&gt;HuffDSCF);
00906                 L[1] = (idx!=8) ? L[0] + idx : mpc_decoder_bitstream_read(d, 6);
00907                 L[2] = L[1];
00908                 <span class="keywordflow">break</span>;
00909             <span class="keywordflow">case</span> 3:
00910                 idx  = mpc_decoder_huffman_decode_fast(d,  d-&gt;HuffDSCF);
00911                 L[0] = (idx!=8) ? L[2] + idx : mpc_decoder_bitstream_read(d, 6);
00912                 L[1] = L[0];
00913                 L[2] = L[1];
00914                 <span class="keywordflow">break</span>;
00915             <span class="keywordflow">case</span> 2:
00916                 idx  = mpc_decoder_huffman_decode_fast(d,  d-&gt;HuffDSCF);
00917                 L[0] = (idx!=8) ? L[2] + idx : mpc_decoder_bitstream_read(d, 6);
00918                 L[1] = L[0];
00919                 idx  = mpc_decoder_huffman_decode_fast(d,  d-&gt;HuffDSCF);
00920                 L[2] = (idx!=8) ? L[1] + idx : mpc_decoder_bitstream_read(d, 6);
00921                 <span class="keywordflow">break</span>;
00922             <span class="keywordflow">case</span> 0:
00923                 idx  = mpc_decoder_huffman_decode_fast(d,  d-&gt;HuffDSCF);
00924                 L[0] = (idx!=8) ? L[2] + idx : mpc_decoder_bitstream_read(d, 6);
00925                 idx  = mpc_decoder_huffman_decode_fast(d,  d-&gt;HuffDSCF);
00926                 L[1] = (idx!=8) ? L[0] + idx : mpc_decoder_bitstream_read(d, 6);
00927                 idx  = mpc_decoder_huffman_decode_fast(d,  d-&gt;HuffDSCF);
00928                 L[2] = (idx!=8) ? L[1] + idx : mpc_decoder_bitstream_read(d, 6);
00929                 <span class="keywordflow">break</span>;
00930             <span class="keywordflow">default</span>:
00931                 <span class="keywordflow">return</span>;
00932                 <span class="keywordflow">break</span>;
00933             }
00934             <span class="comment">// update Reference for DSCF</span>
00935             d-&gt;DSCF_Reference_L[n] = L[2];
00936         }
00937         <span class="keywordflow">if</span> (*ResR)
00938         {
00939             R[2] = d-&gt;DSCF_Reference_R[n];
00940             switch (d-&gt;SCFI_R[n])
00941             {
00942             <span class="keywordflow">case</span> 1:
00943                 idx  = mpc_decoder_huffman_decode_fast(d,  d-&gt;HuffDSCF);
00944                 R[0] = (idx!=8) ? R[2] + idx : mpc_decoder_bitstream_read(d, 6);
00945                 idx  = mpc_decoder_huffman_decode_fast(d,  d-&gt;HuffDSCF);
00946                 R[1] = (idx!=8) ? R[0] + idx : mpc_decoder_bitstream_read(d, 6);
00947                 R[2] = R[1];
00948                 <span class="keywordflow">break</span>;
00949             <span class="keywordflow">case</span> 3:
00950                 idx  = mpc_decoder_huffman_decode_fast(d,  d-&gt;HuffDSCF);
00951                 R[0] = (idx!=8) ? R[2] + idx : mpc_decoder_bitstream_read(d, 6);
00952                 R[1] = R[0];
00953                 R[2] = R[1];
00954                 <span class="keywordflow">break</span>;
00955             <span class="keywordflow">case</span> 2:
00956                 idx  = mpc_decoder_huffman_decode_fast(d,  d-&gt;HuffDSCF);
00957                 R[0] = (idx!=8) ? R[2] + idx : mpc_decoder_bitstream_read(d, 6);
00958                 R[1] = R[0];
00959                 idx  = mpc_decoder_huffman_decode_fast(d,  d-&gt;HuffDSCF);
00960                 R[2] = (idx!=8) ? R[1] + idx : mpc_decoder_bitstream_read(d, 6);
00961                 <span class="keywordflow">break</span>;
00962             <span class="keywordflow">case</span> 0:
00963                 idx  = mpc_decoder_huffman_decode_fast(d,  d-&gt;HuffDSCF);
00964                 R[0] = (idx!=8) ? R[2] + idx : mpc_decoder_bitstream_read(d, 6);
00965                 idx  = mpc_decoder_huffman_decode_fast(d,  d-&gt;HuffDSCF);
00966                 R[1] = (idx!=8) ? R[0] + idx : mpc_decoder_bitstream_read(d, 6);
00967                 idx  = mpc_decoder_huffman_decode_fast(d,  d-&gt;HuffDSCF);
00968                 R[2] = (idx!=8) ? R[1] + idx : mpc_decoder_bitstream_read(d, 6);
00969                 <span class="keywordflow">break</span>;
00970             <span class="keywordflow">default</span>:
00971                 <span class="keywordflow">return</span>;
00972                 <span class="keywordflow">break</span>;
00973             }
00974             <span class="comment">// update Reference for DSCF</span>
00975             d-&gt;DSCF_Reference_R[n] = R[2];
00976         }
00977     }
00978     <span class="comment">/***************************** Samples ****************************/</span>
00979     ResL = d-&gt;Res_L;
00980     ResR = d-&gt;Res_R;
00981     L    = d-&gt;Q[0].L;
00982     R    = d-&gt;Q[0].R;
00983     <span class="keywordflow">for</span> (n=0; n &lt;= Max_used_Band; ++n, ++ResL, ++ResR, L+=36, R+=36)
00984     {
00985         <span class="comment">/************** links **************/</span>
00986         <span class="keywordflow">switch</span> (*ResL)
00987         {
00988         <span class="keywordflow">case</span>  -2: <span class="keywordflow">case</span>  -3: <span class="keywordflow">case</span>  -4: <span class="keywordflow">case</span>  -5: <span class="keywordflow">case</span>  -6: <span class="keywordflow">case</span>  -7: <span class="keywordflow">case</span>  -8: <span class="keywordflow">case</span>  -9:
00989         <span class="keywordflow">case</span> -10: <span class="keywordflow">case</span> -11: <span class="keywordflow">case</span> -12: <span class="keywordflow">case</span> -13: <span class="keywordflow">case</span> -14: <span class="keywordflow">case</span> -15: <span class="keywordflow">case</span> -16: <span class="keywordflow">case</span> -17:
00990             L += 36;
00991             <span class="keywordflow">break</span>;
00992         <span class="keywordflow">case</span> -1:
00993             <span class="keywordflow">for</span> (k=0; k&lt;36; k++ ) {
00994                 tmp  = <a class="code" href="synth__filter_8c.html#a8">random_int</a>(d);
00995                 *L++ = ((tmp &gt;&gt; 24) &amp; 0xFF) + ((tmp &gt;&gt; 16) &amp; 0xFF) + ((tmp &gt;&gt;  8) &amp; 0xFF) + ((tmp &gt;&gt;  0) &amp; 0xFF) - 510;
00996             }
00997             <span class="keywordflow">break</span>;
00998         <span class="keywordflow">case</span> 0:
00999             L += 36;<span class="comment">// increase pointer</span>
01000             <span class="keywordflow">break</span>;
01001         <span class="keywordflow">case</span> 1:
01002             Table = d-&gt;HuffQ[mpc_decoder_bitstream_read(d, 1)][1];
01003             <span class="keywordflow">for</span> (k=0; k&lt;12; ++k)
01004             {
01005                 idx = mpc_decoder_huffman_decode_fast(d,  Table);
01006                 *L++ = idx30[idx];
01007                 *L++ = idx31[idx];
01008                 *L++ = idx32[idx];
01009             }
01010             <span class="keywordflow">break</span>;
01011         <span class="keywordflow">case</span> 2:
01012             Table = d-&gt;HuffQ[mpc_decoder_bitstream_read(d, 1)][2];
01013             <span class="keywordflow">for</span> (k=0; k&lt;18; ++k)
01014             {
01015                 idx = mpc_decoder_huffman_decode_fast(d,  Table);
01016                 *L++ = idx50[idx];
01017                 *L++ = idx51[idx];
01018             }
01019             <span class="keywordflow">break</span>;
01020         <span class="keywordflow">case</span> 3:
01021         <span class="keywordflow">case</span> 4:
01022             Table = d-&gt;HuffQ[mpc_decoder_bitstream_read(d, 1)][*ResL];
01023             <span class="keywordflow">for</span> (k=0; k&lt;36; ++k)
01024                 *L++ = mpc_decoder_huffman_decode_faster(d, Table);
01025             <span class="keywordflow">break</span>;
01026         <span class="keywordflow">case</span> 5:
01027             Table = d-&gt;HuffQ[mpc_decoder_bitstream_read(d, 1)][*ResL];
01028             <span class="keywordflow">for</span> (k=0; k&lt;36; ++k)
01029                 *L++ = mpc_decoder_huffman_decode_fast(d, Table);
01030             <span class="keywordflow">break</span>;
01031         <span class="keywordflow">case</span> 6:
01032         <span class="keywordflow">case</span> 7:
01033             Table = d-&gt;HuffQ[mpc_decoder_bitstream_read(d, 1)][*ResL];
01034             <span class="keywordflow">for</span> (k=0; k&lt;36; ++k)
01035                 *L++ = mpc_decoder_huffman_decode(d, Table);
01036             <span class="keywordflow">break</span>;
01037         <span class="keywordflow">case</span> 8: <span class="keywordflow">case</span> 9: <span class="keywordflow">case</span> 10: <span class="keywordflow">case</span> 11: <span class="keywordflow">case</span> 12: <span class="keywordflow">case</span> 13: <span class="keywordflow">case</span> 14: <span class="keywordflow">case</span> 15: <span class="keywordflow">case</span> 16: <span class="keywordflow">case</span> 17:
01038             tmp = Dc[*ResL];
01039             <span class="keywordflow">for</span> (k=0; k&lt;36; ++k)
01040                 *L++ = (mpc_int32_t)mpc_decoder_bitstream_read(d, Res_bit[*ResL]) - tmp;
01041             <span class="keywordflow">break</span>;
01042         <span class="keywordflow">default</span>:
01043             <span class="keywordflow">return</span>;
01044         }
01045         <span class="comment">/************** rechts **************/</span>
01046         <span class="keywordflow">switch</span> (*ResR)
01047         {
01048         <span class="keywordflow">case</span>  -2: <span class="keywordflow">case</span>  -3: <span class="keywordflow">case</span>  -4: <span class="keywordflow">case</span>  -5: <span class="keywordflow">case</span>  -6: <span class="keywordflow">case</span>  -7: <span class="keywordflow">case</span>  -8: <span class="keywordflow">case</span>  -9:
01049         <span class="keywordflow">case</span> -10: <span class="keywordflow">case</span> -11: <span class="keywordflow">case</span> -12: <span class="keywordflow">case</span> -13: <span class="keywordflow">case</span> -14: <span class="keywordflow">case</span> -15: <span class="keywordflow">case</span> -16: <span class="keywordflow">case</span> -17:
01050             R += 36;
01051             <span class="keywordflow">break</span>;
01052         <span class="keywordflow">case</span> -1:
01053                 <span class="keywordflow">for</span> (k=0; k&lt;36; k++ ) {
01054                     tmp  = <a class="code" href="synth__filter_8c.html#a8">random_int</a>(d);
01055                     *R++ = ((tmp &gt;&gt; 24) &amp; 0xFF) + ((tmp &gt;&gt; 16) &amp; 0xFF) + ((tmp &gt;&gt;  8) &amp; 0xFF) + ((tmp &gt;&gt;  0) &amp; 0xFF) - 510;
01056                 }
01057                 <span class="keywordflow">break</span>;
01058             <span class="keywordflow">case</span> 0:
01059                 R += 36;<span class="comment">// increase pointer</span>
01060                 <span class="keywordflow">break</span>;
01061             <span class="keywordflow">case</span> 1:
01062                 Table = d-&gt;HuffQ[mpc_decoder_bitstream_read(d, 1)][1];
01063                 <span class="keywordflow">for</span> (k=0; k&lt;12; ++k)
01064                 {
01065                     idx = mpc_decoder_huffman_decode_fast(d, Table);
01066                     *R++ = idx30[idx];
01067                     *R++ = idx31[idx];
01068                     *R++ = idx32[idx];
01069                 }
01070                 <span class="keywordflow">break</span>;
01071             <span class="keywordflow">case</span> 2:
01072                 Table = d-&gt;HuffQ[mpc_decoder_bitstream_read(d, 1)][2];
01073                 <span class="keywordflow">for</span> (k=0; k&lt;18; ++k)
01074                 {
01075                     idx = mpc_decoder_huffman_decode_fast(d, Table);
01076                     *R++ = idx50[idx];
01077                     *R++ = idx51[idx];
01078                 }
01079                 <span class="keywordflow">break</span>;
01080             <span class="keywordflow">case</span> 3:
01081             <span class="keywordflow">case</span> 4:
01082                 Table = d-&gt;HuffQ[mpc_decoder_bitstream_read(d, 1)][*ResR];
01083                 <span class="keywordflow">for</span> (k=0; k&lt;36; ++k)
01084                     *R++ = mpc_decoder_huffman_decode_faster(d, Table);
01085                 <span class="keywordflow">break</span>;
01086             <span class="keywordflow">case</span> 5:
01087                 Table = d-&gt;HuffQ[mpc_decoder_bitstream_read(d, 1)][*ResR];
01088                 <span class="keywordflow">for</span> (k=0; k&lt;36; ++k)
01089                     *R++ = mpc_decoder_huffman_decode_fast(d, Table);
01090                 <span class="keywordflow">break</span>;
01091             <span class="keywordflow">case</span> 6:
01092             <span class="keywordflow">case</span> 7:
01093                 Table = d-&gt;HuffQ[mpc_decoder_bitstream_read(d, 1)][*ResR];
01094                 <span class="keywordflow">for</span> (k=0; k&lt;36; ++k)
01095                     *R++ = mpc_decoder_huffman_decode(d, Table);
01096                 <span class="keywordflow">break</span>;
01097             <span class="keywordflow">case</span> 8: <span class="keywordflow">case</span> 9: <span class="keywordflow">case</span> 10: <span class="keywordflow">case</span> 11: <span class="keywordflow">case</span> 12: <span class="keywordflow">case</span> 13: <span class="keywordflow">case</span> 14: <span class="keywordflow">case</span> 15: <span class="keywordflow">case</span> 16: <span class="keywordflow">case</span> 17:
01098                 tmp = Dc[*ResR];
01099                 <span class="keywordflow">for</span> (k=0; k&lt;36; ++k)
01100                     *R++ = (mpc_int32_t)mpc_decoder_bitstream_read(d, Res_bit[*ResR]) - tmp;
01101                 <span class="keywordflow">break</span>;
01102             <span class="keywordflow">default</span>:
01103                 <span class="keywordflow">return</span>;
01104         }
01105     }
01106 }
01107 
<a name="l01108"></a><a class="code" href="mpc__decoder_8c.html#a33">01108</a> <span class="keywordtype">void</span> <a class="code" href="musepack_8h.html#a13">mpc_decoder_setup</a>(mpc_decoder *d, mpc_reader *r)
01109 {
01110   d-&gt;r = r;
01111 
01112   d-&gt;HuffQ[0][0] = 0;
01113   d-&gt;HuffQ[1][0] = 0;
01114   d-&gt;HuffQ[0][1] = d-&gt;HuffQ1[0];
01115   d-&gt;HuffQ[1][1] = d-&gt;HuffQ1[1];
01116   d-&gt;HuffQ[0][2] = d-&gt;HuffQ2[0];
01117   d-&gt;HuffQ[1][2] = d-&gt;HuffQ2[1];
01118   d-&gt;HuffQ[0][3] = d-&gt;HuffQ3[0];
01119   d-&gt;HuffQ[1][3] = d-&gt;HuffQ3[1];
01120   d-&gt;HuffQ[0][4] = d-&gt;HuffQ4[0];
01121   d-&gt;HuffQ[1][4] = d-&gt;HuffQ4[1];
01122   d-&gt;HuffQ[0][5] = d-&gt;HuffQ5[0];
01123   d-&gt;HuffQ[1][5] = d-&gt;HuffQ5[1];
01124   d-&gt;HuffQ[0][6] = d-&gt;HuffQ6[0];
01125   d-&gt;HuffQ[1][6] = d-&gt;HuffQ6[1];
01126   d-&gt;HuffQ[0][7] = d-&gt;HuffQ7[0];
01127   d-&gt;HuffQ[1][7] = d-&gt;HuffQ7[1];
01128 
01129   d-&gt;SampleHuff[0] = NULL;
01130   d-&gt;SampleHuff[1] = d-&gt;Entropie_1;
01131   d-&gt;SampleHuff[2] = d-&gt;Entropie_2;
01132   d-&gt;SampleHuff[3] = d-&gt;Entropie_3;
01133   d-&gt;SampleHuff[4] = d-&gt;Entropie_4;
01134   d-&gt;SampleHuff[5] = d-&gt;Entropie_5;
01135   d-&gt;SampleHuff[6] = d-&gt;Entropie_6;
01136   d-&gt;SampleHuff[7] = d-&gt;Entropie_7;
01137   d-&gt;SampleHuff[8] = NULL;
01138   d-&gt;SampleHuff[9] = NULL;
01139   d-&gt;SampleHuff[10] = NULL;
01140   d-&gt;SampleHuff[11] = NULL;
01141   d-&gt;SampleHuff[12] = NULL;
01142   d-&gt;SampleHuff[13] = NULL;
01143   d-&gt;SampleHuff[14] = NULL;
01144   d-&gt;SampleHuff[15] = NULL;
01145   d-&gt;SampleHuff[16] = NULL;
01146   d-&gt;SampleHuff[17] = NULL;
01147 
01148   d-&gt;EQ_activated = 0;
01149   d-&gt;MPCHeaderPos = 0;
01150   d-&gt;StreamVersion = 0;
01151   d-&gt;MS_used = 0;
01152   d-&gt;FwdJumpInfo = 0;
01153   d-&gt;ActDecodePos = 0;
01154   d-&gt;FrameWasValid = 0;
01155   d-&gt;OverallFrames = 0;
01156   d-&gt;DecodedFrames = 0;
01157   d-&gt;LastValidSamples = 0;
01158   d-&gt;TrueGaplessPresent = 0;
01159   d-&gt;WordsRead = 0;
01160   d-&gt;Max_Band = 0;
01161   d-&gt;SampleRate = 0;
01162 <span class="comment">//  clips = 0;</span>
01163   d-&gt;__r1 = 1;
01164   d-&gt;__r2 = 1;
01165 
01166   d-&gt;dword = 0;
01167   d-&gt;pos = 0;
01168   d-&gt;Zaehler = 0;
01169   d-&gt;WordsRead = 0;
01170   d-&gt;Max_Band = 0;
01171 
01172   mpc_decoder_initialisiere_quantisierungstabellen(d, 1.0f);
01173   <a class="code" href="huffman_8h.html#a2">mpc_decoder_init_huffman_sv6</a>(d);
01174   <a class="code" href="huffman_8h.html#a4">mpc_decoder_init_huffman_sv7</a>(d);
01175 }
01176 
01177 <span class="keyword">static</span> <span class="keywordtype">void</span> mpc_decoder_set_streaminfo(mpc_decoder *d, mpc_streaminfo *si)
01178 {
01179     mpc_decoder_reset_synthesis(d);
01180     mpc_decoder_reset_globals(d);
01181 
01182     d-&gt;StreamVersion      = si-&gt;stream_version;
01183     d-&gt;MS_used            = si-&gt;ms;
01184     d-&gt;Max_Band           = si-&gt;max_band;
01185     d-&gt;OverallFrames      = si-&gt;frames;
01186     d-&gt;MPCHeaderPos       = si-&gt;header_position;
01187     d-&gt;LastValidSamples   = si-&gt;last_frame_samples;
01188     d-&gt;TrueGaplessPresent = si-&gt;is_true_gapless;
01189     d-&gt;SampleRate         = (mpc_int32_t)si-&gt;sample_freq;
01190 
01191     d-&gt;samples_to_skip = MPC_DECODER_SYNTH_DELAY;
01192 }
01193 
<a name="l01194"></a><a class="code" href="mpc__decoder_8c.html#a35">01194</a> BOOL <a class="code" href="musepack_8h.html#a14">mpc_decoder_initialize</a>(mpc_decoder *d, mpc_streaminfo *si) 
01195 {
01196     mpc_decoder_set_streaminfo(d, si);
01197 
01198     <span class="comment">// AB: setting position to the beginning of the data-bitstream</span>
01199     <span class="keywordflow">switch</span> (d-&gt;StreamVersion) {
01200     <span class="keywordflow">case</span> 0x04: f_seek(d, 4 + d-&gt;MPCHeaderPos); d-&gt;pos = 16; <span class="keywordflow">break</span>;  <span class="comment">// Geht auch ber eine der Helperfunktionen</span>
01201     <span class="keywordflow">case</span> 0x05:
01202     <span class="keywordflow">case</span> 0x06: f_seek(d, 8 + d-&gt;MPCHeaderPos); d-&gt;pos =  0; <span class="keywordflow">break</span>;
01203     <span class="keywordflow">case</span> 0x07:
01204     <span class="keywordflow">case</span> 0x17: <span class="comment">/*f_seek ( 24 + d-&gt;MPCHeaderPos );*/</span> d-&gt;pos =  8; <span class="keywordflow">break</span>;
01205     <span class="keywordflow">default</span>: <span class="keywordflow">return</span> FALSE;
01206     }
01207 
01208     <span class="comment">// AB: fill buffer and initialize decoder</span>
01209     f_read_dword(d, d-&gt;Speicher, MEMSIZE );
01210     d-&gt;dword = d-&gt;Speicher[d-&gt;Zaehler = 0];
01211 
01212     <span class="keywordflow">return</span> TRUE;
01213 }
01214 
01215 <span class="comment">//---------------------------------------------------------------</span>
01216 <span class="comment">// will seek from the beginning of the file to the desired</span>
01217 <span class="comment">// position in ms (given by seek_needed)</span>
01218 <span class="comment">//---------------------------------------------------------------</span>
01219 <span class="preprocessor">#if 0</span>
01220 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span>
01221 helper1(mpc_decoder *d, mpc_uint32_t bitpos) 
01222 {
01223     f_seek(d, (bitpos &gt;&gt; 5) * 4 + d-&gt;MPCHeaderPos);
01224     f_read_dword(d, d-&gt;Speicher, 2);
01225     d-&gt;dword = d-&gt;Speicher[d-&gt;Zaehler = 0];
01226     d-&gt;pos = bitpos &amp; 31;
01227 }
01228 <span class="preprocessor">#endif</span>
01229 <span class="preprocessor"></span>
01230 <span class="keyword">static</span> <span class="keywordtype">void</span>
01231 helper2(mpc_decoder *d, mpc_uint32_t bitpos) 
01232 {
01233     f_seek(d, (bitpos&gt;&gt;5) * 4 + d-&gt;MPCHeaderPos);
01234     f_read_dword(d, d-&gt;Speicher, MEMSIZE);
01235     d-&gt;dword = d-&gt;Speicher[d-&gt;Zaehler = 0];
01236     d-&gt;pos = bitpos &amp; 31;
01237 }
01238 
01239 <span class="preprocessor">#if 0</span>
01240 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span>
01241 helper3(mpc_decoder *d, mpc_uint32_t bitpos, mpc_uint32_t* buffoffs) 
01242 {
01243     d-&gt;pos = bitpos &amp; 31;
01244     bitpos &gt;&gt;= 5;
01245     <span class="keywordflow">if</span> ((mpc_uint32_t)(bitpos - *buffoffs) &gt;= MEMSIZE - 2) {
01246         *buffoffs = bitpos;
01247         f_seek(d, bitpos * 4L + d-&gt;MPCHeaderPos);
01248         f_read_dword(d, d-&gt;Speicher, MEMSIZE );
01249     }
01250     d-&gt;dword = d-&gt;Speicher[d-&gt;Zaehler = bitpos - *buffoffs ];
01251 }
01252 <span class="preprocessor">#endif</span>
01253 <span class="preprocessor"></span>
01254 <span class="keyword">static</span> mpc_uint32_t get_initial_fpos(mpc_decoder *d, mpc_uint32_t StreamVersion)
01255 {
01256     mpc_uint32_t fpos = 0;
01257     <span class="keywordflow">switch</span> ( d-&gt;StreamVersion ) {                                                  <span class="comment">// setting position to the beginning of the data-bitstream</span>
01258     <span class="keywordflow">case</span>  0x04: fpos =  48; <span class="keywordflow">break</span>;
01259     <span class="keywordflow">case</span>  0x05:
01260     <span class="keywordflow">case</span>  0x06: fpos =  64; <span class="keywordflow">break</span>;
01261     <span class="keywordflow">case</span>  0x07:
01262     <span class="keywordflow">case</span>  0x17: fpos = 200; <span class="keywordflow">break</span>;
01263     }
01264     <span class="keywordflow">return</span> fpos;
01265 }
01266 
<a name="l01267"></a><a class="code" href="mpc__decoder_8c.html#a38">01267</a> BOOL <a class="code" href="musepack_8h.html#a18">mpc_decoder_seek_seconds</a>(mpc_decoder *d, <span class="keywordtype">double</span> seconds) 
01268 {
01269     <span class="keywordflow">return</span> <a class="code" href="musepack_8h.html#a17">mpc_decoder_seek_sample</a>(d, (mpc_int64_t)(seconds * (<span class="keywordtype">double</span>)d-&gt;SampleRate + 0.5));
01270 }
01271 
<a name="l01272"></a><a class="code" href="musepack_8h.html#a17">01272</a> BOOL <a class="code" href="musepack_8h.html#a17">mpc_decoder_seek_sample</a>(mpc_decoder *d, mpc_int64_t destsample) 
01273 {
01274     mpc_uint32_t fpos;
01275     mpc_uint32_t fwd;
01276 
01277     fwd = (mpc_uint32_t) (destsample / MPC_FRAME_LENGTH);
01278     d-&gt;samples_to_skip = MPC_DECODER_SYNTH_DELAY + (mpc_uint32_t)(destsample % MPC_FRAME_LENGTH);
01279 
01280     memset(d-&gt;Y_L          , 0, <span class="keyword">sizeof</span> d-&gt;Y_L           );
01281     memset(d-&gt;Y_R          , 0, <span class="keyword">sizeof</span> d-&gt;Y_R           );
01282     memset(d-&gt;SCF_Index_L     , 0, <span class="keyword">sizeof</span> d-&gt;SCF_Index_L      );
01283     memset(d-&gt;SCF_Index_R     , 0, <span class="keyword">sizeof</span> d-&gt;SCF_Index_R      );
01284     memset(d-&gt;Res_L           , 0, <span class="keyword">sizeof</span> d-&gt;Res_L            );
01285     memset(d-&gt;Res_R           , 0, <span class="keyword">sizeof</span> d-&gt;Res_R            );
01286     memset(d-&gt;SCFI_L          , 0, <span class="keyword">sizeof</span> d-&gt;SCFI_L           );
01287     memset(d-&gt;SCFI_R          , 0, <span class="keyword">sizeof</span> d-&gt;SCFI_R           );
01288     memset(d-&gt;DSCF_Flag_L     , 0, <span class="keyword">sizeof</span> d-&gt;DSCF_Flag_L      );
01289     memset(d-&gt;DSCF_Flag_R     , 0, <span class="keyword">sizeof</span> d-&gt;DSCF_Flag_R      );
01290     memset(d-&gt;DSCF_Reference_L, 0, <span class="keyword">sizeof</span> d-&gt;DSCF_Reference_L );
01291     memset(d-&gt;DSCF_Reference_R, 0, <span class="keyword">sizeof</span> d-&gt;DSCF_Reference_R );
01292     memset(d-&gt;Q               , 0, <span class="keyword">sizeof</span> d-&gt;Q                );
01293     memset(d-&gt;MS_Flag         , 0, <span class="keyword">sizeof</span> d-&gt;MS_Flag          );
01294 
01295     <span class="comment">// resetting synthesis filter to avoid "clicks"</span>
01296     mpc_decoder_reset_synthesis(d);
01297 
01298     <span class="comment">// prevent from desired position out of allowed range</span>
01299     fwd = fwd &lt; d-&gt;OverallFrames  ?  fwd  :  d-&gt;OverallFrames;
01300 
01301     <span class="comment">// reset number of decoded frames</span>
01302     d-&gt;DecodedFrames = 0;
01303 
01304     fpos = get_initial_fpos(d, d-&gt;StreamVersion);
01305     <span class="keywordflow">if</span> (fpos == 0) {
01306         <span class="keywordflow">return</span> FALSE;
01307     }
01308 
01309     helper2(d, fpos);
01310 
01311     <span class="comment">// read the last 32 frames before the desired position to scan the scalefactors (artifactless jumping)</span>
01312     <span class="keywordflow">for</span> ( ; d-&gt;DecodedFrames &lt; fwd; d-&gt;DecodedFrames++ ) {
01313         mpc_uint32_t   FrameBitCnt;
01314         mpc_uint32_t   RING;
01315         RING         = d-&gt;Zaehler;
01316         d-&gt;FwdJumpInfo  = mpc_decoder_bitstream_read(d, 20);    <span class="comment">// read jump-info</span>
01317         d-&gt;ActDecodePos = (d-&gt;Zaehler &lt;&lt; 5) + d-&gt;pos;
01318         FrameBitCnt  = mpc_decoder_bits_read(d);  <span class="comment">// scanning the scalefactors and check for validity of frame</span>
01319         <span class="keywordflow">if</span> (d-&gt;StreamVersion &gt;= 7)  {
01320             mpc_decoder_read_bitstream_sv7(d);
01321         }
01322         <span class="keywordflow">else</span> {
01323             mpc_decoder_read_bitstream_sv6(d);
01324         }
01325         <span class="keywordflow">if</span> (mpc_decoder_bits_read(d) - FrameBitCnt != d-&gt;FwdJumpInfo ) {
01326             <span class="comment">// Box ("Bug in perform_jump");</span>
01327             <span class="keywordflow">return</span> FALSE;
01328         }
01329         <span class="comment">// update buffer</span>
01330         <span class="keywordflow">if</span> ((RING ^ d-&gt;Zaehler) &amp; MEMSIZE2) {
01331             f_read_dword(d, d-&gt;Speicher + (RING &amp; MEMSIZE2),  MEMSIZE2);
01332         }
01333     }
01334 
01335     <span class="comment">// LastBitsRead = BitsRead ();</span>
01336     <span class="comment">// LastFrame = d-&gt;DecodedFrames;</span>
01337 
01338     <span class="keywordflow">return</span> TRUE;
01339 }
01340 
01341 <span class="keywordtype">void</span> mpc_decoder_update_buffer(mpc_decoder *d, mpc_uint32_t RING) 
01342 {
01343     <span class="keywordflow">if</span> ((RING ^ d-&gt;Zaehler) &amp; MEMSIZE2 ) {
01344         <span class="comment">// update buffer</span>
01345         f_read_dword(d, d-&gt;Speicher + (RING &amp; MEMSIZE2), MEMSIZE2);
01346     }
01347 }
01348 
01349 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sat Jan 22 09:34:07 2005 for libmusepack by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.1 </small></address>
</body>
</html>
